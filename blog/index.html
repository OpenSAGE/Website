<!DOCTYPE html><html lang="en"><head><title data-react-helmet="true">Blog - OpenSAGE</title><meta data-react-helmet="true" name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" as="script" href="/templates/src-pages-blog.4f20723c.js"/><link rel="preload" as="script" href="/templates/styles.7d074083.js"/><link rel="preload" as="script" href="/templates/vendors~main.d9cea79b.js"/><link rel="preload" as="script" href="/main.536602d2.js"/><link rel="preload" as="style" href="/styles.7d074083.css"/><link rel="stylesheet" href="/styles.7d074083.css"/><link data-react-helmet="true" href="https://fonts.googleapis.com/css?family=Noto+Serif+TC|Source+Code+Pro" rel="stylesheet"/><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, shrink-to-fit=no"/></head><body><div id="root"><div style="outline:none" tabindex="-1" role="group" class="page"><header><a aria-current="page" href="/"><div class="header__logo"></div></a><nav class="navbar"><ol class="navbar__items"><li class="nav-item"><a aria-current="page" href="/">About</a></li><li class="nav-item"><a href="/blog">Blog</a></li><li class="nav-item"><a href="https://github.com/OpenSAGE/OpenSAGE">GitHub</a></li><li class="nav-item"><a href="https://discord.gg/G2FhZUT">Discord</a></li></ol></nav></header><div id="main-content"><h1>The OpenSAGE blog</h1>All Posts:<ul><li><a href="/blog/post/hello_world_2/">Hello, world 2<!-- --> (<!-- -->2018-12-16<!-- -->)</a></li><li><a href="/blog/post/hello_world/">Hello, world!<!-- --> (<!-- -->2018-12-15<!-- -->)</a></li><li><a href="/blog/post/dev_diary_2/">OpenSAGE Dev Diary #2<!-- --> (<!-- -->2017-12-10<!-- -->)</a></li><li><a href="/blog/post/dev_diary_1/">OpenSAGE Dev Diary #1<!-- --> (<!-- -->2017-12-03<!-- -->)</a></li></ul></div><footer><div class="footer__content"><p>OpenSAGE is an open source project and not associated with Electronic Arts or any other company. All trademarks are property of their respective owners. Screenshots of copyrighted works are only used for demonstration purposes.</p><p>Â© OpenSAGE <!-- -->2018</p></div></footer></div></div><script type="text/javascript">
    window.__routeInfo = {"templateIndex":1,"sharedDataHashes":{},"localProps":null,"path":"blog","allProps":{"posts":[{"title":"Hello, world 2","author":"Paavo Huhtala","publishedDate":"2018-12-16","id":"hello_world_2","html":"<p>Hello!</p>\n\n          <h2>\n            <a name=\"neat-o\" href=\"#neat-o\">\n            Neat-o\n            </a>\n          </h2><p>Hello!</p>\n"},{"title":"Hello, world!","author":"Paavo Huhtala","publishedDate":"2018-12-15","id":"hello_world","html":"<p>Hello!</p>\n\n          <h2>\n            <a name=\"neat-o\" href=\"#neat-o\">\n            Neat-o\n            </a>\n          </h2><p>Hello!</p>\n"},{"title":"OpenSAGE Dev Diary #2","author":"Tim Jones","publishedDate":"2017-12-10","id":"dev_diary_2","html":"<p><em><a href=\"http://timjones.io/blog/archive/2017/12/10/opensage-dev-diary-2-2017-12-10\">This post</a> was originally published on Tim&#39;s blog.</em></p>\n<p>Following on from <a href=\"/blog/archive/2017/12/03/opensage-dev-diary-2017-12-03\">last week&#39;s post</a>, here is what&#39;s been happening this week in OpenSAGE.</p>\n\n          <h2>\n            <a name=\"progress-this-week\" href=\"#progress-this-week\">\n            Progress this week\n            </a>\n          </h2><p>This week, I have:</p>\n<ul>\n<li><p>Implemented a new build system for shaders. Previously, shaders were compiled (at build time) using the <a href=\"https://www.nuget.org/packages/Microsoft.HLSL.CSharpVB/\">Microsoft.HLSL.CSharpVB MSBuild targets</a> from NuGet. This had a couple of limitations: first, the method this NuGet package used to find <code>fxc.exe</code> <a href=\"https://github.com/OpenSAGE/OpenSAGE/issues/8\">didn&#39;t work</a> with recent Windows Kits. Second, vertex and pixel shaders had to be in separate files, which didn&#39;t fit well with the runtime Effect system I&#39;ve been building. The new shader build system uses a custom MSBuild <code>.targets</code> file and a custom C# MSBuild <code>Task</code> to compile all the <code>.fx</code> files found in the OpenSage.Game project, and embed the resulting bytecode as embedded resources. <a href=\"https://github.com/OpenSAGE/OpenSAGE/tree/master/build\">Source code here</a>.</p>\n</li>\n<li><p>Started implementing a GUI renderer. More details on GUI rendering below.</p>\n</li>\n<li><p>Started porting the existing Data Viewer application from WPF to <a href=\"https://github.com/picoe/Eto\">Eto.Forms</a>, a cross-platform UI framework that, like Xamarin Forms, uses native widgets on each platform. I plan to bring OpenSAGE to the Mac soon, and this is an important preparatory step.</p>\n</li>\n</ul>\n\n          <h2>\n            <a name=\"gui-rendering\" href=\"#gui-rendering\">\n            GUI rendering\n            </a>\n          </h2><p>In C&amp;C Generals, almost all the UI (i.e. everything except for the 3D bits) is defined in <code>.wnd</code> files. This includes the main menu, the options screen, the multiplayer game setup screen, even the command bar at the bottom of the screen during gameplay.</p>\n<p><code>.wnd</code> are plain-text files that look like this:</p>\n<pre><code>FILE_VERSION = 2;\nSTARTLAYOUTBLOCK\n  LAYOUTINIT = &quot;[None]&quot;;\n  LAYOUTUPDATE = &quot;[None]&quot;;\n  LAYOUTSHUTDOWN = &quot;[None]&quot;;\nENDLAYOUTBLOCK\nWINDOW\n  WINDOWTYPE = USER;\n  SCREENRECT = UPPERLEFT: 0 0,\n               BOTTOMRIGHT: 800 600,\n               CREATIONRESOLUTION: 800 600;\n  NAME = &quot;TheName&quot;;\n  STATUS = ENABLED+IMAGE;\n  STYLE = USER;\n  SYSTEMCALLBACK = &quot;[None]&quot;;\n  INPUTCALLBACK = &quot;[None]&quot;;\n  TOOLTIPCALLBACK = &quot;[None]&quot;;\n  DRAWCALLBACK = &quot;[None]&quot;;\n  FONT = NAME: &quot;Times New Roman&quot;, SIZE: 14, BOLD: 0;\n  HEADERTEMPLATE = &quot;[None]&quot;;\n  TOOLTIPDELAY = -1;\n  TEXTCOLOR = ENABLED:  255 255 255 255, ENABLEDBORDER:  255 255 255 255,\n              DISABLED: 255 255 255 255, DISABLEDBORDER: 255 255 255 255,\n              HILITE:   255 255 255 255, HILITEBORDER:   255 255 255 255;\n  ENABLEDDRAWDATA = IMAGE: SomeImageName, COLOR: 0 0 128 255, BORDERCOLOR: 254 254 254 255,\n                    ...\n  DISABLEDDRAWDATA = IMAGE: NoImage, COLOR: 64 64 64 255, BORDERCOLOR: 254 254 254 255,\n                     ...\n  HILITEDRAWDATA = IMAGE: NoImage, COLOR: 128 128 255 255, BORDERCOLOR: 254 254 254 255,\n                   ...\n  CHILD\n     ... Child window\n  WINDOW\n  ENDALLCHILDREN\nEND</code></pre><p>A <code>WINDOW</code> definition (which is really an element of a window) contains information about size, colour, background image.\nThere are different window types for textboxes, listboxes, etc. Windows can have child windows, so something like the main menu\nhas a large hierarchy of &quot;windows&quot;.</p>\n<p>I couldn&#39;t find any information about <code>.wnd</code> files by Googling, so I had to figure it out the hard way. For example, you can see above that there are references to images (<code>ENABLEDDRAWDATA = IMAGE: SomeImageName</code>). These don&#39;t correspond directly to images on disk. Instead, there is a folder of <code>.ini</code> files called MappedImages, and in there you&#39;ll find entries like this:</p>\n<pre><code>MappedImage SomeImageName\n  Texture = TheActualTexture.tga\n  TextureWidth = 1024\n  TextureHeight = 256\n  Coords = Left:0 Top:64 Right:800 Bottom:255\n  Status = NONE\nEnd</code></pre><p>These <code>MappedImage</code> entries contain the actual texture, as well as coordinates within that texture. Most GUI textures contain images for lots of GUI elements, so these coordinates provide the specific rectangle to use for a given GUI element.</p>\n<p>I&#39;ve implemented a <code>.wnd</code> parser, and started on implementing a GUI renderer. Here&#39;s where I&#39;ve got to this week: the basic bits are in place, but I&#39;m not yet rendering text, and there&#39;s no mouse or keyboard input yet.</p>\n<p><a href=\"/assets/posts/dev_diary_2/opensage-2017-12-10-gui.png\"><img src=\"/assets/posts/dev_diary_2/opensage-2017-12-10-gui-thumb.jpg\" title=\"OpenSAGE GUI - C&amp;C Generals Main Menu\"/></a></p>\n<p>For reference, here is what the same screen looks like in the original game:</p>\n<p><a href=\"/assets/posts/dev_diary_2/opensage-2017-12-10-gui-original.png\"><img src=\"/assets/posts/dev_diary_2/opensage-2017-12-10-gui-original-thumb.jpg\" title=\"C&amp;C Generals Main Menu\"/></a></p>\n<p>Still plenty of work to do, but it&#39;s a start.</p>\n\n          <h2>\n            <a name=\"next-week\" href=\"#next-week\">\n            Next week\n            </a>\n          </h2><p>Next, I&#39;m planning to finish porting the Data Viewer application to Eto.Forms, and then keep going with GUI rendering.</p>\n<p>See you next time!</p>\n"},{"title":"OpenSAGE Dev Diary #1","author":"Tim Jones","publishedDate":"2017-12-03","id":"dev_diary_1","html":"<p><em><a href=\"http://timjones.io/blog/archive/2017/12/03/opensage-dev-diary-2017-12-03\">This post</a> was originally published on Tim&#39;s blog.</em></p>\n<p>This is the first in what I hope will be a continuing series of updates on <a href=\"https://github.com/OpenSAGE/OpenSAGE\">OpenSAGE</a>, my C&amp;C Generals re-implementation project.</p>\n<p>I&#39;ve been working on OpenSAGE for about 6 months now. I&#39;m still working on parsing and rendering the basic data files (3D models, maps, etc.). There isn&#39;t yet any playable executable. Instead, there&#39;s a &quot;Data Viewer&quot; application, which lists all the files found in the Generals (or Zero Hour) installation folder, and lets you view these files. I&#39;ve found this approach helpful while writing parsers for the various file formats found in Generals. At some point, I&#39;ll transition to working on gameplay, and start to build up a playable executable.</p>\n<p>Here is what the data viewer looks like. Here I&#39;m viewing the USA Command Center 3D model:</p>\n<p><a href=\"/assets/posts/dev_diary_1/opensage-2017-12-03-data-viewer.png\"><img src=\"/assets/posts/dev_diary_1/opensage-2017-12-03-data-viewer-thumb.jpg\" title=\"OpenSAGE Data Viewer\"/></a></p>\n<p>I meant to start writing about this project soon after I started it, but clearly that didn&#39;t happen. Instead of trying to list everything I&#39;ve done in the last 6 months, I&#39;ll just start from a week ago, and then try to keep up-to-date from now.</p>\n\n          <h2>\n            <a name=\"progress-this-week\" href=\"#progress-this-week\">\n            Progress this week\n            </a>\n          </h2><p>This week, I have:</p>\n<ul>\n<li>Switched from a D3D12 renderer to a D3D11 renderer. I started out with a Direct3D 12 renderer because I wanted to learn Direct3D 12. Having done that, I realise it&#39;s not sensible for this particular project to require an API that only works on Windows 10. Direct3D 11 works on Windows 7 and above, and since many people are still on Windows 7, that&#39;s a better minimum requirement. I plan to add a Metal renderer (for macOS and iOS), and possibly Vulkan (for Android), depending on how popular this project is.</li>\n<li>In order to render the terrain and 3D meshes, I was previously relying on a D3D12-only feature called dynamic texture indexing. This allowed me, for example when rendering a map, to put all the terrain textures in a big array and send that to the GPU, and the pixel shader could dynamically index the right texture. Dynamic texture indexing of an array of textures (i.e. <code>Texture2D[]</code>) isn&#39;t supported in D3D11, so I instead used D3D11&#39;s closest equivalent, a texture array (<code>Texture2DArray</code>).</li>\n<li><code>Texture2DArray</code> requires all the textures in the array to have the same size and format (unlike <code>Texture2D[]</code>, where textures can have arbitrary sizes and formats). The terrain textures used in Generals maps are not all the same size. There are 4 possible sizes: 64x64, 128x128, 256x256, and 384x384. In order to put all these into a <code>Texture2DArray</code>, I had to upsample the smaller textures to 384x384. Not a perfect solution, but it was the least bad option I could think of, while keeping the nice ability to render an entire terrain patch with a single draw call.</li>\n<li>Added a friendlier resource binding API. Previously, to set shader resources, I had to hard-code the resource slot in my C# code. Now I can use the name of the resource, as declared in HLSL, and using shader reflection I can match this to the resource slot.</li>\n<li>Added a stub for a Bink video parser. Currently I can parse the container format, but not yet any of the video or audio packets. Cinematic videos in Generals use the Bink video format (stored in <code>.bik</code> files), and up to now I&#39;ve had a prototype Bink viewer that uses <a href=\"https://www.ffmpeg.org/\">FFmpeg</a> to play them. I&#39;m toying with the possibility of implementing a Bink parser and renderer completely in C#, to remove the FFmpeg dependency. Native dependencies cause all sorts of headaches for cross-platform deployments, so I&#39;d like to avoid them if I can. That said, Bink is not a simple format, so it might turn out to be a bad idea to try to implement it myself.</li>\n<li>Fixed some memory leaks. I noticed, when shutting down the data viewer app, that Direct3D complained in the Visual Studio output window about unreleased live resources. I tracked these down to a place where I&#39;d forgotten to dispose some D3D objects.</li>\n<li>Abstracted the material system to support shader materials. 3D models in Generals and Zero Hour all use vertex materials, which were built on D3D8&#39;s fixed-function pipeline. Later SAGE games (Battle for Middle-earth II, C&amp;C3, RA3) use shaders. I wanted to support both types of rendering early on, so that I don&#39;t need to do lots of refactoring later. Model rendering can now use either <code>FixedFunctionMaterial</code> (which still uses shaders, but it emulates a Generals-era fixed-function pipeline) or <code>ShaderMaterial</code>.</li>\n</ul>\n<p>So, lots of refactoring and internal changes this week.</p>\n<p>Next week I plan to work on the GUI. I have a prototype GUI renderer, built on WPF. I plan to rip this out and build a new one based on lower-level drawing APIs (Direct2D on Windows, and later, <code>CGContext</code> on macOS and iOS). Stay tuned!</p>\n<p>Although I haven&#39;t done any work on maps this week, allow me to finish with a screenshot showing the current state of map rendering:</p>\n<p><a href=\"/assets/posts/dev_diary_1/opensage-2017-12-03-data-viewer-map-usa03.png\"><img src=\"/assets/posts/dev_diary_1/opensage-2017-12-03-data-viewer-map-usa03-thumb.jpg\" title=\"OpenSAGE Data Viewer - USA03 Map\"/></a></p>\n"}]},"siteData":{}};</script><script defer="" type="text/javascript" src="/templates/src-pages-blog.4f20723c.js"></script><script defer="" type="text/javascript" src="/templates/styles.7d074083.js"></script><script defer="" type="text/javascript" src="/templates/vendors~main.d9cea79b.js"></script><script defer="" type="text/javascript" src="/main.536602d2.js"></script></body></html>