<!DOCTYPE html><html lang="en"><head><link rel="preload" as="script" href="/templates/vendors~src-containers-Post~src-pages-blog.a7ec12c7.js"/><link rel="preload" as="script" href="/templates/vendors~src-pages-blog.11a618ee.js"/><link rel="preload" as="script" href="/templates/src-pages-blog.db69bdb0.js"/><link rel="preload" as="script" href="/templates/styles.0627da3d.js"/><link rel="preload" as="script" href="/templates/vendors~main.97a2a2ec.js"/><link rel="preload" as="script" href="/main.19fe689c.js"/><link rel="preload" as="style" href="/styles.0627da3d.css"/><link rel="stylesheet" href="/styles.0627da3d.css"/><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, shrink-to-fit=no"/></head><body><div id="root"><div style="outline:none" tabindex="-1" role="group" class="page"><header><a aria-current="page" href="/"><div class="header__logo"></div></a><nav class="navbar"><ol class="navbar__items"><li class="nav-item"><a aria-current="page" href="/">About</a></li><li class="nav-item"><a href="/blog">Blog</a></li><li class="nav-item"><a href="https://github.com/OpenSAGE/OpenSAGE">GitHub</a></li><li class="nav-item"><a href="https://discord.gg/G2FhZUT">Discord</a></li></ol></nav></header><div id="main-content"><h1>The OpenSAGE blog</h1><h2>2018</h2><ul><li><a href="/blog/post/hello_world_2/">Hello, world 2<!-- --> (<!-- -->2018-12-16<!-- -->)</a></li><li><a href="/blog/post/hello_world/">Hello, world!<!-- --> (<!-- -->2018-12-15<!-- -->)</a></li></ul><h2>2017</h2><ul><li><a href="/blog/post/dev_diary_3/">OpenSAGE Dev Diary #3<!-- --> (<!-- -->2017-12-17<!-- -->)</a></li><li><a href="/blog/post/dev_diary_2/">OpenSAGE Dev Diary #2<!-- --> (<!-- -->2017-12-10<!-- -->)</a></li><li><a href="/blog/post/dev_diary_1/">OpenSAGE Dev Diary #1<!-- --> (<!-- -->2017-12-03<!-- -->)</a></li></ul></div><footer><div class="footer__content"><p>OpenSAGE is an open source project and not associated with Electronic Arts or any other company. All trademarks are property of their respective owners. Screenshots of copyrighted works are only used for demonstration purposes.</p><p>Â© OpenSAGE <!-- -->2018</p></div></footer></div></div><script type="text/javascript">
    window.__routeInfo = {"templateIndex":1,"sharedDataHashes":{},"localProps":null,"path":"blog","allProps":{"posts":[{"title":"Hello, world 2","author":"Paavo Huhtala","publishedDate":"2018-12-16","id":"hello_world_2","html":"<p>Hello!</p>\n\n          <h2>\n            <a name=\"neat-o\" href=\"#neat-o\">\n            Neat-o\n            </a>\n          </h2><p>Hello!</p>\n"},{"title":"Hello, world!","author":"Paavo Huhtala","publishedDate":"2018-12-15","id":"hello_world","html":"<p>Hello!</p>\n\n          <h2>\n            <a name=\"neat-o\" href=\"#neat-o\">\n            Neat-o\n            </a>\n          </h2><p>Hello!</p>\n"},{"title":"OpenSAGE Dev Diary #3","author":"Tim Jones","publishedDate":"2017-12-17","id":"dev_diary_3","html":"<p><em>OpenSAGE is an open-source re-implementation of the <a href=\"https://en.wikipedia.org/wiki/SAGE_(game_engine)\">SAGE game engine</a>. SAGE was the game engine used in C&amp;C Generals, C&amp;C Generals Zero Hour, Battle for Middle-earth and its sequels, C&amp;C 3 and its sequel, and Red Alert 3 and its sequel. I&#39;ve been working on OpenSAGE for 6 months, and made some good progress, so I&#39;ve started this series of blog posts to talk about what is happening in the project each week. You can also star or watch the <a href=\"https://github.com/OpenSAGE/OpenSAGE\">OpenSAGE GitHub repo</a> for a more real-time view of things.</em></p>\n<p>Following on from <a href=\"/blog/post/dev_diary_2/\">last week&#39;s post</a>, here is what&#39;s been happening this week in <a href=\"https://github.com/OpenSAGE/OpenSAGE\">OpenSAGE</a>.</p>\n\n          <h2>\n            <a name=\"progress-this-week\" href=\"#progress-this-week\">\n            Progress this week\n            </a>\n          </h2><p><a href=\"/assets/posts/dev_diary_3/opensage-2017-12-17-gui-main-menu.png\"><img src=\"/assets/posts/dev_diary_3/opensage-2017-12-17-gui-main-menu-thumb.jpg\" title=\"GUI - Main Menu\"/></a></p>\n<p>This week in OpenSAGE:</p>\n<ul>\n<li><p>I&#39;ve finished porting the data viewer from WPF to <a href=\"https://github.com/picoe/Eto\">Eto.Forms</a>. I haven&#39;t really introduced what the data viewer is, so I&#39;ll do that below. I want OpenSAGE to be a cross-platform project (it&#39;s Windows-only right now), and I&#39;d like the data viewer to at least be on whatever desktop platforms OpenSAGE supports, if not mobile. Xamarin Forms was an option, but on Windows it only supports UWP (a WPF port of Xamarin Forms is in the works, apparently, but not ready yet). UWP is no good for OpenSAGE because of the way it handles file system permissions. So for the data viewer, I wanted a cross-platform UI framework that runs on at least WPF, macOS, and Linux. Eto.Forms ticks those boxes. Having used it for a couple of weeks, I&#39;m really impressed with how easy it is to get up and running. I want to thank <a href=\"https://twitter.com/cwensley\">Curtis Wensley</a> for making and maintaining such an awesome framework. I built a <a href=\"https://github.com/OpenSAGE/OpenSAGE/blob/master/src/OpenSage.DataViewer.Windows/Controls/GameControlHandler.cs\">custom control</a> to render 3D content, and it couldn&#39;t have been easier to integrate with Eto.Forms.</p>\n</li>\n<li><p>I&#39;ve made progress on rendering the various GUI screens from C&amp;C Generals. Thankfully the GUI screens (main menu, options screen, game loading screen, game setup screen, etc.) are defined in parse-able data files, not hardcoded in the game&#39;s binary. This week I have implemented text rendering (using DirectWrite) - quite a critical feature for GUI screens... I&#39;ll talk more about GUI rendering below.</p>\n</li>\n<li><p>I merged a <a href=\"https://github.com/OpenSAGE/OpenSAGE/pull/11\">pull request</a> from <a href=\"https://github.com/feliwir\">Stephan Vedder</a> that added support for <code>.const</code> files. <code>.const</code> files were used in Battle for Middle-earth (BFME) and later SAGE games, as part of the Flash-based UI system. This is a whole new area that I haven&#39;t done any work on myself, so it&#39;s exciting to see it starting to appear in OpenSAGE - thanks Stephan!</p>\n</li>\n<li><p>I have started to setup a <a href=\"https://en.wikipedia.org/wiki/Continuous_integration\">CI</a> build. Normally I&#39;d setup an AppVeyor build and be done with it, but my requirements for OpenSAGE are a bit different. Most of OpenSAGE&#39;s <a href=\"https://github.com/OpenSAGE/OpenSAGE/tree/master/src/OpenSage.Game.Tests\">tests</a> use the actual data files from SAGE game installations. For copyright reasons, I can&#39;t upload those data files anywhere. So I&#39;ve settled on <a href=\"https://www.visualstudio.com/vso/\">Visual Studio Team Services</a>, which lets me use a private build agent to do the builds. I&#39;ve got a computer running at home, with all the SAGE games installed, that will be a private build agent and run the OpenSAGE test suite whenever it&#39;s instructed to by VSTS. I&#39;m still setting this up, so for now the build badge in the GitHub readme shows a failing build.</p>\n</li>\n</ul>\n\n          <h2>\n            <a name=\"data-viewer\" href=\"#data-viewer\">\n            Data viewer\n            </a>\n          </h2><p>When I started working on OpenSAGE, I realised it would be good to have a way to preview the results of the file format parsers that I was working on. At that time I was working on a <code>.map</code> parser. <code>.map</code> files in Generals can contain both multi-player maps and single-player missions; they contain the terrain data as well as scripts needed for multi-player or single-player games. Since I didn&#39;t yet have an in-game UI, I built a simple WPF app with two panels: on the left, a list of files contained in the Generals folder, and on the right, a preview of the selected file. I built previewers for the main file formats as I figured out them out: <code>.w3d</code>, <code>.map</code>, <code>.ini</code>, etc.</p>\n<p>Once OpenSAGE is far enough along in development that it&#39;s possible to start a game from the in-game UI, the data viewer will become less important, but still a helpful way to view individual files. For now, there is no &quot;game&quot; executable, so the data viewer is all there is.</p>\n<p>This week I finished porting the data viewer from WPF to Eto.Forms, so that it can work on macOS and Linux. I haven&#39;t yet implemented rendering backends for either of those platforms, but at least I&#39;ve removed one of the obstacles.</p>\n<p>Here are screenshots with representative examples of all the file types that the OpenSAGE Data Viewer knows how to handle:</p>\n\n          <h3>\n            <a name=\"w-3-d\" href=\"#w-3-d\">\n            .w3d\n            </a>\n          </h3><p><code>.w3d</code> files were used in C&amp;C Generals and subsequent SAGE games to store 3D models. C&amp;C 3 and later games used an evolution of this format, called <code>.w3x</code>, which is kind of the same thing but XML-based.</p>\n<p><a href=\"/assets/posts/dev_diary_3/opensage-2017-12-17-data-viewer-w3d.png\"><img src=\"/assets/posts/dev_diary_3/opensage-2017-12-17-data-viewer-w3d-thumb.jpg\" title=\"W3D Viewer\"/></a></p>\n\n          <h3>\n            <a name=\"map\" href=\"#map\">\n            .map\n            </a>\n          </h3><p><code>.map</code> files store the single-player and multi-player missions, including terrain data and scripts. The <code>.map</code> viewer lets you change the time of day, which affects lighting.</p>\n<p><a href=\"/assets/posts/dev_diary_3/opensage-2017-12-17-data-viewer-map.png\"><img src=\"/assets/posts/dev_diary_3/opensage-2017-12-17-data-viewer-map-thumb.jpg\" title=\"Map Viewer\"/></a></p>\n\n          <h3>\n            <a name=\"dds-and-tga\" href=\"#dds-and-tga\">\n            .dds and .tga\n            </a>\n          </h3><p><code>.dds</code> files were used to store 3D model textures, and <code>.tga</code> files were used for terrain and UI textures.</p>\n<p><a href=\"/assets/posts/dev_diary_3/opensage-2017-12-17-data-viewer-dds.png\"><img src=\"/assets/posts/dev_diary_3/opensage-2017-12-17-data-viewer-dds-thumb.jpg\" title=\"DDS Viewer\"/></a></p>\n\n          <h3>\n            <a name=\"csf\" href=\"#csf\">\n            .csf\n            </a>\n          </h3><p><code>.csf</code> - compiled string files - stored the translated strings.</p>\n<p><a href=\"/assets/posts/dev_diary_3/opensage-2017-12-17-data-viewer-csf.png\"><img src=\"/assets/posts/dev_diary_3/opensage-2017-12-17-data-viewer-csf-thumb.jpg\" title=\"CSF Viewer\"/></a></p>\n\n          <h3>\n            <a name=\"const\" href=\"#const\">\n            .const\n            </a>\n          </h3><p><code>.const</code> files store constant value definitions for use in the <code>.apt</code> UI framework.</p>\n<p><a href=\"/assets/posts/dev_diary_3/opensage-2017-12-17-data-viewer-const.png\"><img src=\"/assets/posts/dev_diary_3/opensage-2017-12-17-data-viewer-const-thumb.jpg\" title=\"Const Viewer\"/></a></p>\n\n          <h3>\n            <a name=\"ini\" href=\"#ini\">\n            .ini\n            </a>\n          </h3><p><code>.ini</code> files were used in Generals and subsequent SAGE games to store almost everything about the game, except for what was stored in other file types. My <code>.ini</code> viewer currently only displays object definitions and particle systems.</p>\n<p><a href=\"/assets/posts/dev_diary_3/opensage-2017-12-17-data-viewer-ini.png\"><img src=\"/assets/posts/dev_diary_3/opensage-2017-12-17-data-viewer-ini-thumb.jpg\" title=\"Const Viewer\"/></a></p>\n\n          <h2>\n            <a name=\"gui-rendering\" href=\"#gui-rendering\">\n            GUI rendering\n            </a>\n          </h2><p>Last week I mentioned the <code>.wnd</code> format used for UI screens in C&amp;C Generals. This week I&#39;ve been working on rendering more parts of it, including text. Here&#39;s the current state of the main menu (defined in <code>MainMenu.wnd</code>):</p>\n<p><a href=\"/assets/posts/dev_diary_3/opensage-2017-12-17-gui-main-menu.png\"><img src=\"/assets/posts/dev_diary_3/opensage-2017-12-17-gui-main-menu-thumb.jpg\" title=\"GUI - Main Menu\"/></a></p>\n<p>Some UI elements are visible that should be hidden - I still need to look at why that&#39;s so. Buttons respond to mouse hover now, but they don&#39;t yet do anything when clicked.</p>\n<p><a href=\"/assets/posts/dev_diary_3/opensage-2017-12-17-gui-options.png\"><img src=\"/assets/posts/dev_diary_3/opensage-2017-12-17-gui-options-thumb.jpg\" title=\"GUI - Options\"/></a></p>\n<p>This is the Options menu. There&#39;s much more to do here. I need to implement textboxes, checkboxes, and comboboxes.</p>\n<p>And here&#39;s one we all like to see - the victory screen. Yes, even that was defined in a <code>.wnd</code> file, not hardcoded.</p>\n<p><a href=\"/assets/posts/dev_diary_3/opensage-2017-12-17-gui-victorious.png\"><img src=\"/assets/posts/dev_diary_3/opensage-2017-12-17-gui-victorious-thumb.jpg\" title=\"GUI - Victorious\"/></a></p>\n<p>The <code>.wnd</code> viewer has the UI hierarchy in a tree view on the left - you can select a UI element and it will be highlighted on the right.</p>\n<p>That&#39;s all for this week - see you next time!</p>\n"},{"title":"OpenSAGE Dev Diary #2","author":"Tim Jones","publishedDate":"2017-12-10","id":"dev_diary_2","html":"<p><em><a href=\"http://timjones.io/blog/archive/2017/12/10/opensage-dev-diary-2-2017-12-10\">This post</a> was originally published on Tim&#39;s blog.</em></p>\n<p>Following on from <a href=\"/blog/post/dev_diary_1/\">last week&#39;s post</a>, here is what&#39;s been happening this week in OpenSAGE.</p>\n\n          <h2>\n            <a name=\"progress-this-week\" href=\"#progress-this-week\">\n            Progress this week\n            </a>\n          </h2><p>This week, I have:</p>\n<ul>\n<li><p>Implemented a new build system for shaders. Previously, shaders were compiled (at build time) using the <a href=\"https://www.nuget.org/packages/Microsoft.HLSL.CSharpVB/\">Microsoft.HLSL.CSharpVB MSBuild targets</a> from NuGet. This had a couple of limitations: first, the method this NuGet package used to find <code>fxc.exe</code> <a href=\"https://github.com/OpenSAGE/OpenSAGE/issues/8\">didn&#39;t work</a> with recent Windows Kits. Second, vertex and pixel shaders had to be in separate files, which didn&#39;t fit well with the runtime Effect system I&#39;ve been building. The new shader build system uses a custom MSBuild <code>.targets</code> file and a custom C# MSBuild <code>Task</code> to compile all the <code>.fx</code> files found in the OpenSage.Game project, and embed the resulting bytecode as embedded resources. <a href=\"https://github.com/OpenSAGE/OpenSAGE/tree/master/build\">Source code here</a>.</p>\n</li>\n<li><p>Started implementing a GUI renderer. More details on GUI rendering below.</p>\n</li>\n<li><p>Started porting the existing Data Viewer application from WPF to <a href=\"https://github.com/picoe/Eto\">Eto.Forms</a>, a cross-platform UI framework that, like Xamarin Forms, uses native widgets on each platform. I plan to bring OpenSAGE to the Mac soon, and this is an important preparatory step.</p>\n</li>\n</ul>\n\n          <h2>\n            <a name=\"gui-rendering\" href=\"#gui-rendering\">\n            GUI rendering\n            </a>\n          </h2><p>In C&amp;C Generals, almost all the UI (i.e. everything except for the 3D bits) is defined in <code>.wnd</code> files. This includes the main menu, the options screen, the multiplayer game setup screen, even the command bar at the bottom of the screen during gameplay.</p>\n<p><code>.wnd</code> are plain-text files that look like this:</p>\n<pre><code>FILE_VERSION = 2;\nSTARTLAYOUTBLOCK\n  LAYOUTINIT = &quot;[None]&quot;;\n  LAYOUTUPDATE = &quot;[None]&quot;;\n  LAYOUTSHUTDOWN = &quot;[None]&quot;;\nENDLAYOUTBLOCK\nWINDOW\n  WINDOWTYPE = USER;\n  SCREENRECT = UPPERLEFT: 0 0,\n               BOTTOMRIGHT: 800 600,\n               CREATIONRESOLUTION: 800 600;\n  NAME = &quot;TheName&quot;;\n  STATUS = ENABLED+IMAGE;\n  STYLE = USER;\n  SYSTEMCALLBACK = &quot;[None]&quot;;\n  INPUTCALLBACK = &quot;[None]&quot;;\n  TOOLTIPCALLBACK = &quot;[None]&quot;;\n  DRAWCALLBACK = &quot;[None]&quot;;\n  FONT = NAME: &quot;Times New Roman&quot;, SIZE: 14, BOLD: 0;\n  HEADERTEMPLATE = &quot;[None]&quot;;\n  TOOLTIPDELAY = -1;\n  TEXTCOLOR = ENABLED:  255 255 255 255, ENABLEDBORDER:  255 255 255 255,\n              DISABLED: 255 255 255 255, DISABLEDBORDER: 255 255 255 255,\n              HILITE:   255 255 255 255, HILITEBORDER:   255 255 255 255;\n  ENABLEDDRAWDATA = IMAGE: SomeImageName, COLOR: 0 0 128 255, BORDERCOLOR: 254 254 254 255,\n                    ...\n  DISABLEDDRAWDATA = IMAGE: NoImage, COLOR: 64 64 64 255, BORDERCOLOR: 254 254 254 255,\n                     ...\n  HILITEDRAWDATA = IMAGE: NoImage, COLOR: 128 128 255 255, BORDERCOLOR: 254 254 254 255,\n                   ...\n  CHILD\n     ... Child window\n  WINDOW\n  ENDALLCHILDREN\nEND</code></pre><p>A <code>WINDOW</code> definition (which is really an element of a window) contains information about size, colour, background image.\nThere are different window types for textboxes, listboxes, etc. Windows can have child windows, so something like the main menu\nhas a large hierarchy of &quot;windows&quot;.</p>\n<p>I couldn&#39;t find any information about <code>.wnd</code> files by Googling, so I had to figure it out the hard way. For example, you can see above that there are references to images (<code>ENABLEDDRAWDATA = IMAGE: SomeImageName</code>). These don&#39;t correspond directly to images on disk. Instead, there is a folder of <code>.ini</code> files called MappedImages, and in there you&#39;ll find entries like this:</p>\n<pre><code>MappedImage SomeImageName\n  Texture = TheActualTexture.tga\n  TextureWidth = 1024\n  TextureHeight = 256\n  Coords = Left:0 Top:64 Right:800 Bottom:255\n  Status = NONE\nEnd</code></pre><p>These <code>MappedImage</code> entries contain the actual texture, as well as coordinates within that texture. Most GUI textures contain images for lots of GUI elements, so these coordinates provide the specific rectangle to use for a given GUI element.</p>\n<p>I&#39;ve implemented a <code>.wnd</code> parser, and started on implementing a GUI renderer. Here&#39;s where I&#39;ve got to this week: the basic bits are in place, but I&#39;m not yet rendering text, and there&#39;s no mouse or keyboard input yet.</p>\n<p><a href=\"/assets/posts/dev_diary_2/opensage-2017-12-10-gui.png\"><img src=\"/assets/posts/dev_diary_2/opensage-2017-12-10-gui-thumb.jpg\" title=\"OpenSAGE GUI - C&amp;C Generals Main Menu\"/></a></p>\n<p>For reference, here is what the same screen looks like in the original game:</p>\n<p><a href=\"/assets/posts/dev_diary_2/opensage-2017-12-10-gui-original.png\"><img src=\"/assets/posts/dev_diary_2/opensage-2017-12-10-gui-original-thumb.jpg\" title=\"C&amp;C Generals Main Menu\"/></a></p>\n<p>Still plenty of work to do, but it&#39;s a start.</p>\n\n          <h2>\n            <a name=\"next-week\" href=\"#next-week\">\n            Next week\n            </a>\n          </h2><p>Next, I&#39;m planning to finish porting the Data Viewer application to Eto.Forms, and then keep going with GUI rendering.</p>\n<p>See you next time!</p>\n"},{"title":"OpenSAGE Dev Diary #1","author":"Tim Jones","publishedDate":"2017-12-03","id":"dev_diary_1","html":"<p><em><a href=\"http://timjones.io/blog/archive/2017/12/03/opensage-dev-diary-2017-12-03\">This post</a> was originally published on Tim&#39;s blog.</em></p>\n<p>This is the first in what I hope will be a continuing series of updates on <a href=\"https://github.com/OpenSAGE/OpenSAGE\">OpenSAGE</a>, my C&amp;C Generals re-implementation project.</p>\n<p>I&#39;ve been working on OpenSAGE for about 6 months now. I&#39;m still working on parsing and rendering the basic data files (3D models, maps, etc.). There isn&#39;t yet any playable executable. Instead, there&#39;s a &quot;Data Viewer&quot; application, which lists all the files found in the Generals (or Zero Hour) installation folder, and lets you view these files. I&#39;ve found this approach helpful while writing parsers for the various file formats found in Generals. At some point, I&#39;ll transition to working on gameplay, and start to build up a playable executable.</p>\n<p>Here is what the data viewer looks like. Here I&#39;m viewing the USA Command Center 3D model:</p>\n<p><a href=\"/assets/posts/dev_diary_1/opensage-2017-12-03-data-viewer.png\"><img src=\"/assets/posts/dev_diary_1/opensage-2017-12-03-data-viewer-thumb.jpg\" title=\"OpenSAGE Data Viewer\"/></a></p>\n<p>I meant to start writing about this project soon after I started it, but clearly that didn&#39;t happen. Instead of trying to list everything I&#39;ve done in the last 6 months, I&#39;ll just start from a week ago, and then try to keep up-to-date from now.</p>\n\n          <h2>\n            <a name=\"progress-this-week\" href=\"#progress-this-week\">\n            Progress this week\n            </a>\n          </h2><p>This week, I have:</p>\n<ul>\n<li>Switched from a D3D12 renderer to a D3D11 renderer. I started out with a Direct3D 12 renderer because I wanted to learn Direct3D 12. Having done that, I realise it&#39;s not sensible for this particular project to require an API that only works on Windows 10. Direct3D 11 works on Windows 7 and above, and since many people are still on Windows 7, that&#39;s a better minimum requirement. I plan to add a Metal renderer (for macOS and iOS), and possibly Vulkan (for Android), depending on how popular this project is.</li>\n<li>In order to render the terrain and 3D meshes, I was previously relying on a D3D12-only feature called dynamic texture indexing. This allowed me, for example when rendering a map, to put all the terrain textures in a big array and send that to the GPU, and the pixel shader could dynamically index the right texture. Dynamic texture indexing of an array of textures (i.e. <code>Texture2D[]</code>) isn&#39;t supported in D3D11, so I instead used D3D11&#39;s closest equivalent, a texture array (<code>Texture2DArray</code>).</li>\n<li><code>Texture2DArray</code> requires all the textures in the array to have the same size and format (unlike <code>Texture2D[]</code>, where textures can have arbitrary sizes and formats). The terrain textures used in Generals maps are not all the same size. There are 4 possible sizes: 64x64, 128x128, 256x256, and 384x384. In order to put all these into a <code>Texture2DArray</code>, I had to upsample the smaller textures to 384x384. Not a perfect solution, but it was the least bad option I could think of, while keeping the nice ability to render an entire terrain patch with a single draw call.</li>\n<li>Added a friendlier resource binding API. Previously, to set shader resources, I had to hard-code the resource slot in my C# code. Now I can use the name of the resource, as declared in HLSL, and using shader reflection I can match this to the resource slot.</li>\n<li>Added a stub for a Bink video parser. Currently I can parse the container format, but not yet any of the video or audio packets. Cinematic videos in Generals use the Bink video format (stored in <code>.bik</code> files), and up to now I&#39;ve had a prototype Bink viewer that uses <a href=\"https://www.ffmpeg.org/\">FFmpeg</a> to play them. I&#39;m toying with the possibility of implementing a Bink parser and renderer completely in C#, to remove the FFmpeg dependency. Native dependencies cause all sorts of headaches for cross-platform deployments, so I&#39;d like to avoid them if I can. That said, Bink is not a simple format, so it might turn out to be a bad idea to try to implement it myself.</li>\n<li>Fixed some memory leaks. I noticed, when shutting down the data viewer app, that Direct3D complained in the Visual Studio output window about unreleased live resources. I tracked these down to a place where I&#39;d forgotten to dispose some D3D objects.</li>\n<li>Abstracted the material system to support shader materials. 3D models in Generals and Zero Hour all use vertex materials, which were built on D3D8&#39;s fixed-function pipeline. Later SAGE games (Battle for Middle-earth II, C&amp;C3, RA3) use shaders. I wanted to support both types of rendering early on, so that I don&#39;t need to do lots of refactoring later. Model rendering can now use either <code>FixedFunctionMaterial</code> (which still uses shaders, but it emulates a Generals-era fixed-function pipeline) or <code>ShaderMaterial</code>.</li>\n</ul>\n<p>So, lots of refactoring and internal changes this week.</p>\n<p>Next week I plan to work on the GUI. I have a prototype GUI renderer, built on WPF. I plan to rip this out and build a new one based on lower-level drawing APIs (Direct2D on Windows, and later, <code>CGContext</code> on macOS and iOS). Stay tuned!</p>\n<p>Although I haven&#39;t done any work on maps this week, allow me to finish with a screenshot showing the current state of map rendering:</p>\n<p><a href=\"/assets/posts/dev_diary_1/opensage-2017-12-03-data-viewer-map-usa03.png\"><img src=\"/assets/posts/dev_diary_1/opensage-2017-12-03-data-viewer-map-usa03-thumb.jpg\" title=\"OpenSAGE Data Viewer - USA03 Map\"/></a></p>\n"}]},"siteData":{}};</script><script defer="" type="text/javascript" src="/templates/vendors~src-containers-Post~src-pages-blog.a7ec12c7.js"></script><script defer="" type="text/javascript" src="/templates/vendors~src-pages-blog.11a618ee.js"></script><script defer="" type="text/javascript" src="/templates/src-pages-blog.db69bdb0.js"></script><script defer="" type="text/javascript" src="/templates/styles.0627da3d.js"></script><script defer="" type="text/javascript" src="/templates/vendors~main.97a2a2ec.js"></script><script defer="" type="text/javascript" src="/main.19fe689c.js"></script></body></html>